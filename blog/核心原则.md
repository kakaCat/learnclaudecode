模式就是agent

一、Unix 哲学 一切皆文件
bash agent

- /dev、/proc、/sys 将设备与内核状态以文件呈现
- echo 1 > /proc/sys/net/ipv4/ip_forward 启用路由
- /dev/null 作为黑洞设备，重定向丢弃输出
- 套接字、FIFO、终端统一以文件描述符访问
二、一个程序只做好一件事（
bash agent细化 read write grep 

- grep 只做模式匹配，awk 做字段处理，sed 做流编辑
- sort、uniq、wc 各司其职，组合完成统计
- tar 归档与 gzip 压缩分离，通过管道协同
三、用管道连接程序，组合完成复杂任务

- cat access.log | grep 500 | awk '{print $7}' | sort | uniq -c | sort -nr
- find . -type f -name '*.log' -print0 | xargs -0 grep -i error
- dmesg | grep -i fail | less

四、配置存放在纯文本文件

- /etc/hosts、/etc/fstab、/etc/resolv.conf
- /etc/ssh/sshd_config、systemd unit 文件
- 用户级 .bashrc、.vimrc、.gitconfig

五、提供机制，而非策略

- VFS 抽象统一文件接口，策略交给上层
- pipe、socket、epoll 提供机制，如何使用由应用决定
- cgroups、namespaces 提供隔离与资源控制框架
- eBPF 提供可编程钩子，不限定具体策略
- LSM（SELinux/AppArmor）安全机制可插拔

六、沉默是金

- 成功返回 0，不打印多余输出；失败用非 0 退出码
- mv、cp 成功不啰嗦；grep 无匹配时安静但退出码区分
- 输出可管道化，错误写到标准错误（stderr）

七、避免花哨的交互界面

- 优先稳定 CLI 与文本协议，便于脚本化与远程操作
- ncurses/TUI 在需要时提供简洁交互，默认保持简单
- 一切皆文件与管道让工具易组合，替代复杂 GUI 流程

用最小、最通用的积木，通过简单规则组合，解决无限复杂的问题。

## Unix 一切皆文件 → Agent 一切皆资源

总纲：

Unix 用“一切皆文件 + bash + 小工具”把人接到操作系统；
我们用“一切皆资源 + CLI 工具 + planner agent”把 LLM 接到软件世界。
只要这个抽象层稳定，这套 agent 框架就不会过时。

一、为什么“一切皆文件”→“会 bash 就会系统”

- 在 Unix 里，代码、配置、日志、设备、内核状态、管道、socket 都被抽象成“文件”
- 内核通过 VFS 暴露统一的 open/read/write/ioctl 原语
- 再加一个前端（shell/bash）和一小撮小工具（ls、cat、grep、sed、awk、curl…）
- 人就可以查看系统状态、修改行为、访问网络和服务——本质都是“操作文件”

二、映射到 LLM：LLM + bash = 最小 OS 接口

- 人类：看终端 → 敲命令 → 看输出 → 再敲下一条
- LLM：看上下文 → 产生命令调用 → 读输出 → 再决定下一步
- 关键能力：
  - 结构化地调用 CLI（如 ["ls","-l","/"]），而不是随意乱打字符串
  - 能读取 stdout/stderr，并基于输出选择下一步工具
- 再叠加：
  - 权限与沙箱（受限目录/网络，禁止 rm -rf / 等危险操作）
  - 超时与配额（防止死循环、fork bomb）
- 这层就是 LLM ↔ OS 的“防腐层 / 适配层”

三、Agent 框架的三条硬原则

- 原则 A：一切皆文件 → 一切皆资源/消息  
  - 对 agent 来说，世界是一组资源（文件、HTTP、DB、进程…）和消息
  - 对资源的操作统一抽象为“命令/工具调用”，类似 open/read/write
- 原则 B：bash / CLI 是 LLM 的“系统调用接口”  
  - 不让 LLM 直接碰内核，而是通过：
    - bash + 小工具
    - 或者“bash 风格的抽象工具层”（等价的 CLI 协议）
  - 可以继承 Unix 生态，并方便做 chroot、容器、虚拟文件系统等隔离
- 原则 C：一个程序只做好一件事 → 小工具优先，复杂逻辑交给组合  
  - 暴露给 LLM 的是很多小工具/子 agent：read、write、grep、http_request、db_query…
  - 复杂任务交给：
    - plan（规划步骤和依赖）
    - pipe/调用链（把上一步输出接成下一步输入）

四、LLM 视角下的“类 Unix 世界”四层结构

- 最底层：真实 OS（文件、网络、进程等）
- 中间层：安全的 bash/CLI 代理  
  - 暴露受控目录/网络环境
  - 命令白名单/黑名单
  - 记录日志、限制资源
- 上一层：LLM 工具接口  
  - 工具名 + 参数，相当于命令 + 参数
  - 工具之间约定数据流/管道协议
- 顶层：agent / planner  
  - 读用户目标
  - 选择工具、排定顺序、编排调用链
  - 像写 shell pipeline 一样“编程”，只是程序员变成 LLM

五、边界条件：能力、观测、安全

- 能力边界：LLM 只看得见被暴露出来的工具和资源，其他等价于不存在
- 观测边界：LLM 只能通过文本/结构化输出感知世界，没映射成输出的状态就是盲区
- 安全边界：危险能力必须通过沙箱、白名单、审计包装，就像不给普通用户 root 一样

这套映射让“模式就是 agent”落在一个非常硬的类比上：  
Unix 用“一切皆文件 + bash + 小工具”连接人和操作系统；  
我们用“一切皆资源/消息 + CLI 工具 + planner agent”连接 LLM 和整个软件世界。
