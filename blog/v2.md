一个程序只做好一件事



1. 安全边界更清晰

bash 可以加危险命令黑名单（rm -rf /, sudo 等）
文件操作工具可以独立做路径沙箱（safe_path() 限制在 WORKDIR 内）
如果只有 bash，cat ../../../etc/passwd 很难拦截
2. 模型决策更精准

模型看到 read_file 就知道"这是读文件"，不需要推断 cat 的语义
edit_file 的 old_text/new_text 参数强制模型做精确替换，而不是生成整个文件的 sed 命令
减少模型写错 shell 语法的概率
3. edit_file 是关键优势

纯 bash 做外科手术式修改很麻烦：
4. 输出可控

每个工具都有 50KB 截断，bash 的 stdout+stderr 合并处理，文件读取有 limit 参数——这些在单一 bash 工具里要靠模型自己加 | head -n 100，不可靠。

5. 审计和日志更清晰

> read_file: {"path": "src/main.py"} 比 > bash: {"command": "cat src/main.py"} 更易于日志分析和权限控制。
核心权衡：工具越细，模型的意图越明确，安全边界越好控制，但工具数量增加会占用更多 context token（工具定义本身也要传给模型）